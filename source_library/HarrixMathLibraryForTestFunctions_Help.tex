\documentclass[a4paper,12pt]{article}

\input{packages}
\input{styles}

\title{HarrixMathLibraryForTestFunctions v.1.0}
\author{А.\,Б. Сергиенко}
\date{\today}


\begin{document}

\input{names}

\maketitle

\begin{abstract}
Библиотека HarrixMathLibraryForTestFunctions --- это множество функций для работы с тестовыми функциями.
\end{abstract}

\tableofcontents

\newpage

Об установке библиотеки можно прочитать тут: тут http://blog.harrix.org/?p=1279.

\section{Введение}

Библиотека HarrixMathLibraryForTestFunctions --- это множество функций для работы с тестовыми функциями.

Последнюю версию документа можно найти по адресу:

\href{https://github.com/Harrix/HarrixMathLibraryForTestFunctions}{https://github.com/Harrix/HarrixMathLibraryForTestFunctions}

Об установке библиотеки можно прочитать тут:

\href{http://blog.harrix.org/?p=1279}{http://blog.harrix.org/?p=1279}

С автором можно связаться по адресу \href{mailto:sergienkoanton@mail.ru}{sergienkoanton@mail.ru} или  \href{http://vk.com/harrix}{http://vk.com/harrix}.

Сайт автора, где публикуются последние новости: \href{http://blog.harrix.org/}{http://blog.harrix.org/}, а проекты располагаются по адресу \href{http://harrix.org/}{http://harrix.org/}.

\newpage
\section{Список функций}\label{section_listfunctions}
\textbf{Для тестовых функций}
\begin{enumerate}

\item \textbf{\hyperref[MHL_ClassOfTestFunction]{MHL\_ClassOfTestFunction}} --- Функция выдает принадлежность тестовой функции к классу функций: бинарной, вещественной или иной оптимизации.

\item \textbf{\hyperref[MHL_CountOfFitnessOfTestFunction_Binary]{MHL\_CountOfFitnessOfTestFunction\_Binary}} --- Функция определяет количество вычислений целевой функции для тестовых задач для единообразного сравнения алгоритмов. Включает в себя все тестовые функции вещественной оптимизации.

\item \textbf{\hyperref[MHL_CountOfFitnessOfTestFunction_Real]{MHL\_CountOfFitnessOfTestFunction\_Real}} --- Функция определяет количество вычислений целевой функции для тестовых задач для единообразного сравнения алгоритмов. Включает в себя все тестовые функции вещественной оптимизации.

\item \textbf{\hyperref[MHL_DefineTestFunction]{MHL\_DefineTestFunction}} --- Служебная функция определяет тестовую функцию для других функций по работе с тестовыми функциями.

\item \textbf{\hyperref[MHL_DimensionTestFunction_Binary]{MHL\_DimensionTestFunction\_Binary}} --- Функция определяет размерность тестовой задачи для тестовой функции бинарной оптимизации по номеру подзадачи (число подзадач по функции MHL\_GetCountOfSubProblems\_Binary).

\item \textbf{\hyperref[MHL_DimensionTestFunction_Real]{MHL\_DimensionTestFunction\_Real}} --- Функция определяет размерность тестовой задачи для тестовой функции вещественной оптимизации по номеру подзадачи (число подзадач по функции MHL\_GetCountOfSubProblems\_Binary).

\item \textbf{\hyperref[MHL_ErrorExOfTestFunction_Binary]{MHL\_ErrorExOfTestFunction\_Binary}} --- Функция определяет значение ошибки по входным параметрам найденного решения в задаче оптимизации для тестовой функции. Включает в себя все тестовые функции бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_ErrorExOfTestFunction_Real]{MHL\_ErrorExOfTestFunction\_Real}} --- Функция определяет значение ошибки по входным параметрам найденного решения в задаче оптимизации для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_ErrorEyOfTestFunction_Binary]{MHL\_ErrorEyOfTestFunction\_Binary}} --- Функция определяет значение ошибки по значениям целевой функции найденного решения в задаче оптимизации для тестовой функции. Включает в себя все тестовые функции бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_ErrorEyOfTestFunction_Real]{MHL\_ErrorEyOfTestFunction\_Real}} --- Функция определяет значение ошибки по значениям целевой функции найденного решения в задаче оптимизации для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_ErrorROfTestFunction_Binary]{MHL\_ErrorROfTestFunction\_Binary}} --- Функция определяет значение надежности найденного решения в задаче оптимизации для тестовой функции. Включает в себя все тестовые функции бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_ErrorROfTestFunction_Real]{MHL\_ErrorROfTestFunction\_Real}} --- Функция определяет значение надежности найденного решения в задаче оптимизации для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции  вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_FitnessOfOptimumOfTestFunction_Binary]{MHL\_FitnessOfOptimumOfTestFunction\_Binary}} --- Функция определяет значение целевой функции в оптимуме для тестовой функции бинарной оптимизации. Включает в себя все тестовые функции бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_FitnessOfOptimumOfTestFunction_Real]{MHL\_FitnessOfOptimumOfTestFunction\_Real}} --- Функция определяет значение целевой функции в оптимуме для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_GetCountOfFitness]{MHL\_GetCountOfFitness}} --- Функция выдает количество вызовов целевой функции.

\item \textbf{\hyperref[MHL_GetCountOfSubProblems_Binary]{MHL\_GetCountOfSubProblems\_Binary}} --- Функция определяет число подзадач (включая основную задачу) для тестовой функции бинарной оптимизации. Включает в себя все тестовые функции бинарной оптимизации.

\item \textbf{\hyperref[MHL_GetCountOfSubProblems_Real]{MHL\_GetCountOfSubProblems\_Real}} --- Функция определяет число подзадач (включая основную задачу) для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации.

\item \textbf{\hyperref[MHL_LeftBorderOfTestFunction_Real]{MHL\_LeftBorderOfTestFunction\_Real}} --- Функция определяет левые и правые границы допустимой области для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_MaximumOrMinimumOfTestFunction_Binary]{MHL\_MaximumOrMinimumOfTestFunction\_Binary}} --- 	Функция сообщает - ищется максимум или минимум в задаче оптимизации для тестовой функции бинарной оптимизации.

\item \textbf{\hyperref[MHL_MaximumOrMinimumOfTestFunction_Real]{MHL\_MaximumOrMinimumOfTestFunction\_Real}} --- 	Функция сообщает - ищется максимум или минимум в задаче оптимизации для тестовой функции вещественной оптимизации.

\item \textbf{\hyperref[MHL_NumberOfPartsOfTestFunction_Real]{MHL\_NumberOfPartsOfTestFunction\_Real}} --- Функция определяет на сколько частей нужно делить каждую координату в задаче оптимизации для тестовой функции вещественной оптимизации для алгоритма дискретной оптимизации и какая при этом требуется точность для подсчета надежности. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_OptimumOfTestFunction_Binary]{MHL\_OptimumOfTestFunction\_Binary}} --- Функция определяет значение оптимума для тестовой функции. Включает в себя все тестовые функции бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_OptimumOfTestFunction_Real]{MHL\_OptimumOfTestFunction\_Real}} --- Функция определяет значение оптимума для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_PrecisionOfCalculationsOfTestFunction_Real]{MHL\_PrecisionOfCalculationsOfTestFunction\_Real}} --- Функция определяет точность для подсчета надежности в задаче оптимизации для тестовой функции вещественной оптимизации для алгоритма дискретной оптимизации.

\item \textbf{\hyperref[MHL_SetToZeroCountOfFitness]{MHL\_SetToZeroCountOfFitness}} --- Функция обнуляет количество вызовов целевой функции. Обязательно вызвать один раз перед вызовом алгоритмов оптимизации при исследовании эффективности    алгоритмов оптимизации, где требуется контроль числа вызовов целевой функции.

\item \textbf{\hyperref[MHL_TestFunction_Binary]{MHL\_TestFunction\_Binary}} --- Общая тестовая функция для задач бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\item \textbf{\hyperref[MHL_TestFunction_Real]{MHL\_TestFunction\_Real}} --- Общая тестовая функция для задач вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.

\end{enumerate}


\newpage
\section{Функции}
\subsection{Для тестовых функций}

\subsubsection{MHL\_ClassOfTestFunction}\label{MHL_ClassOfTestFunction}

Функция выдает принадлежность тестовой функции к классу функций: бинарной, вещественной или иной оптимизации.


\begin{lstlisting}[label=code_syntax_MHL_ClassOfTestFunction,caption=Синтаксис]
int MHL_ClassOfTestFunction(TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Type --- тип тестовой функции. Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла.

\textbf{Возвращаемое значение:}

Класс тестовой функции:

\begin{enumerate}
\item 1 - бинарной оптимизации;
\item 2 - вещественной оптимизации.
\end{enumerate}


\begin{lstlisting}[label=code_use_MHL_ClassOfTestFunction,caption=Пример использования]
TypeOfTestFunction Type=TestFunction_Ackley;

//Вызов функции
int ClassOfTestFunction=MHL_ClassOfTestFunction(Type);

//используем результат
if (ClassOfTestFunction==1)
    MHL_ShowText("Это задача бинарной оптимизации");
if (ClassOfTestFunction==2)
    MHL_ShowText("Это задача вещественной оптимизации");
//Это задача вещественной оптимизации.
\end{lstlisting}

\subsubsection{MHL\_CountOfFitnessOfTestFunction\_Binary}\label{MHL_CountOfFitnessOfTestFunction_Binary}

Функция определяет количество вычислений целевой функции для тестовых задач для единообразного сравнения алгоритмов. Включает в себя все тестовые функции вещественной оптимизации.


\begin{lstlisting}[label=code_syntax_MHL_CountOfFitnessOfTestFunction_Binary,caption=Синтаксис]
int MHL_CountOfFitnessOfTestFunction_Binary(int Dimension);
int MHL_CountOfFitnessOfTestFunction_Binary(int Dimension, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Dimension --- размерность тестовой задачи. Может принимать значения: 20; 30; 40; 50; 60; 70; 80; 90; 100; 200.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем. 

Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Количество вычислений целевой функции для тестовых задач.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_CountOfFitnessOfTestFunction_Binary,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

int Dimension = 30;

//Вызов функции
int  N=MHL_CountOfFitnessOfTestFunction_Binary(Dimension);

//Использование результата
MHL_ShowNumber(N,"Количество вычислений целевой функции для TestFunction_SumVector при размерности 30","N");
//Количество вычислений целевой функции для TestFunction_SumVector при размерности 30:
//N=400
\end{lstlisting}

\subsubsection{MHL\_CountOfFitnessOfTestFunction\_Real}\label{MHL_CountOfFitnessOfTestFunction_Real}

Функция определяет количество вычислений целевой функции для тестовых задач для единообразного сравнения алгоритмов. Включает в себя все тестовые функции вещественной оптимизации.


\begin{lstlisting}[label=code_syntax_MHL_CountOfFitnessOfTestFunction_Real,caption=Синтаксис]
int MHL_CountOfFitnessOfTestFunction_Real(int Dimension);
int MHL_CountOfFitnessOfTestFunction_Real(int Dimension, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Dimension --- размерность тестовой задачи. Может принимать значения: 2; 3; 4; 5; 10; 20; 30.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем. 

Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Количество вычислений целевой функции для тестовых задач.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_CountOfFitnessOfTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

int Dimension = 3;

//Вызов функции
int  N=MHL_CountOfFitnessOfTestFunction_Real(Dimension);

//Использование результата
MHL_ShowNumber(N,"Количество вычислений целевой функции для TestFunction_Ackley при размерности 3","N");
//Количество вычислений целевой функции для TestFunction_Ackley при размерности 3:
//N=729
\end{lstlisting}

\subsubsection{MHL\_DefineTestFunction}\label{MHL_DefineTestFunction}

Служебная функция определяет тестовую функцию для других функций по работе с тестовыми функциями.


\begin{lstlisting}[label=code_syntax_MHL_DefineTestFunction,caption=Синтаксис]
void MHL_DefineTestFunction(TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Отсутствует.


\begin{lstlisting}[label=code_use_MHL_DefineTestFunction,caption=Пример использования]
//Вызов функции
MHL_DefineTestFunction(TestFunction_SumVector);

//Использование результата
int N=5;
int *x=new int[N];
TMHL_RandomBinaryVector(x,N);
double f=MHL_TestFunction_Binary(x,N);

MHL_ShowVectorT(x,N,"Решение","x");
//Решение:
//x =	
//1	1	1	1	0

MHL_ShowNumber(f,"Значение целевой функции","f");
//Значение целевой функции:
//f=4
\end{lstlisting}

\subsubsection{MHL\_DimensionTestFunction\_Binary}\label{MHL_DimensionTestFunction_Binary}

Функция определяет размерность тестовой задачи для тестовой функции бинарной оптимизации по номеру подзадачи (число подзадач по функции MHL\_GetCountOfSubProblems\_Binary).


\begin{lstlisting}[label=code_syntax_MHL_DimensionTestFunction_Binary,caption=Синтаксис]
int MHL_DimensionTestFunction_Binary(int i);
int MHL_DimensionTestFunction_Binary(int i, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

\textbf{i} - номер подзадачи (начиная с нуля).

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем. 

Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Размерность тестовой задачи для тестовой функции бинарной оптимизации.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_DimensionTestFunction_Binary,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

//Вызов функции
double N=MHL_DimensionTestFunction_Binary(0);

//Использование результата
MHL_ShowNumber(N,"Размерность тестовой задачи для TestFunction_SumVector при i=0","N");
//Размерность тестовой задачи для TestFunction_SumVector при i=0:
//N=20
\end{lstlisting}

\subsubsection{MHL\_DimensionTestFunction\_Real}\label{MHL_DimensionTestFunction_Real}

Функция определяет размерность тестовой задачи для тестовой функции вещественной оптимизации по номеру подзадачи (число подзадач по функции MHL\_GetCountOfSubProblems\_Binary).


\begin{lstlisting}[label=code_syntax_MHL_DimensionTestFunction_Real,caption=Синтаксис]
int MHL_DimensionTestFunction_Real(int i);
int MHL_DimensionTestFunction_Real(int i, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

\textbf{i} - номер подзадачи (начиная с нуля).

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем. 

Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Размерность тестовой задачи для тестовой функции вещественной оптимизации.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_DimensionTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

//Вызов функции
double N=MHL_DimensionTestFunction_Real(0);

//Использование результата
MHL_ShowNumber(N,"Размерность тестовой задачи для TestFunction_Ackley при i=0","N");
//Размерность тестовой задачи для TestFunction_Ackley при i=0:
//N=2
\end{lstlisting}

\subsubsection{MHL\_ErrorExOfTestFunction\_Binary}\label{MHL_ErrorExOfTestFunction_Binary}

Функция определяет значение ошибки по входным параметрам найденного решения в задаче оптимизации для тестовой функции. Включает в себя все тестовые функции бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_ErrorExOfTestFunction_Binary,caption=Синтаксис]
double MHL_ErrorExOfTestFunction_Binary(int *x, int VMHL_N);
double MHL_ErrorExOfTestFunction_Binary(int *x, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

x --- указатель на исходный массив (найденное решение алгоритмом);

VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение ошибки по входным параметрам Ex.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.

Конкретную формулу, которые используются для нахождения для каждой тестовой функции, смотрите в функциях этих тестовых функций. Обратите внимание, что данная функция находит ошибку только для одного решения, тогда как по формулам нужно множество решений.


\begin{lstlisting}[label=code_use_MHL_ErrorExOfTestFunction_Binary,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

int N=5;
int *x=new int[N];
TMHL_RandomBinaryVector(x,N);

//Вызов функции
double Ex=MHL_ErrorExOfTestFunction_Binary(x,N);

//Использование результата
MHL_ShowVectorT(x,N,"Решение","x");
//Решение:
//x =	
//1	0	1	1	1

MHL_ShowNumber(Ex,"Значение ошибки по входным параметрам","E<sub>x</sub>");
//Значение ошибки по входным параметрам:
//Ex=1
\end{lstlisting}

\subsubsection{MHL\_ErrorExOfTestFunction\_Real}\label{MHL_ErrorExOfTestFunction_Real}

Функция определяет значение ошибки по входным параметрам найденного решения в задаче оптимизации для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_ErrorExOfTestFunction_Real,caption=Синтаксис]
double MHL_ErrorExOfTestFunction_Real(double *x, int VMHL_N);
double MHL_ErrorExOfTestFunction_Real(double *x, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

x --- указатель на исходный массив (найденное решение алгоритмом);

VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение ошибки по входным параметрам Ex.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.

Конкретную формулу, которые используются для нахождения для каждой тестовой функции, смотрите в функциях этих тестовых функций. Обратите внимание, что данная функция находит ошибку только для одного решения, тогда как по формулам нужно множество решений.


\begin{lstlisting}[label=code_use_MHL_ErrorExOfTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

int N=5;
double *x=new double[N];
MHL_RandomRealVector(x,-0.5,0.05,N);

//Вызов функции
double Ex=MHL_ErrorExOfTestFunction_Real(x,N);

//Использование результата
MHL_ShowVectorT(x,N,"Решение","x");
//Решение:
//x =
//-0.43694	-0.458693	-0.0266388	0.0117142	-0.136948


MHL_ShowNumber(Ex,"Значение ошибки по входным параметрам","E<sub>x</sub>");
//Значение ошибки по входным параметрам:
//Ex=0.129756
\end{lstlisting}

\subsubsection{MHL\_ErrorEyOfTestFunction\_Binary}\label{MHL_ErrorEyOfTestFunction_Binary}

Функция определяет значение ошибки по значениям целевой функции найденного решения в задаче оптимизации для тестовой функции. Включает в себя все тестовые функции бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_ErrorEyOfTestFunction_Binary,caption=Синтаксис]
double MHL_ErrorEyOfTestFunction_Binary(double FitnessOfx, int VMHL_N);
double MHL_ErrorEyOfTestFunction_Binary(double FitnessOfx, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

FitnessOfx --- значение целевой функции найденного решения алгоритмом оптимизации;

VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение ошибки по значениям целевой функции Ey.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.

Конкретную формулу, которые используются для нахождения для каждой тестовой функции, смотрите в функциях этих тестовых функций. Обратите внимание, что данная функция находит ошибку только для одного решения, тогда как по формулам нужно множество решений.

Все функции так высчитываются, чтобы алгоритм решал задачу поиска максимального значения целевой функции, поэтому тестовые функции на минимум умножаются на $-1$. Поэтому, фактически алгоритмы оптимизации находят максимум перевернутой функции. А значит, чтобы правильно посчитать ошибку по значениям целевой функции, нужно найденное решение умножить на $-1$.


\begin{lstlisting}[label=code_use_MHL_ErrorEyOfTestFunction_Binary,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

int N=5;
int *x=new int[N];
TMHL_RandomBinaryVector(x,N);
double f=MHL_TestFunction_Binary(x,N);

//Вызов функции
double Ey=MHL_ErrorEyOfTestFunction_Binary(f,N);

//Использование результата
MHL_ShowVectorT(x,N,"Решение","x");
//Решение:
//x =	
//0	1	1	0	1

MHL_ShowNumber(Ey,"Значение ошибки по значениям целевой функции","E<sub>y</sub>");
//Значение ошибки по значениям целевой функции:
//Ey=2
\end{lstlisting}

\subsubsection{MHL\_ErrorEyOfTestFunction\_Real}\label{MHL_ErrorEyOfTestFunction_Real}

Функция определяет значение ошибки по значениям целевой функции найденного решения в задаче оптимизации для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_ErrorEyOfTestFunction_Real,caption=Синтаксис]
double MHL_ErrorEyOfTestFunction_Real(double FitnessOfx, int VMHL_N);
double MHL_ErrorEyOfTestFunction_Real(double FitnessOfx, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

FitnessOfx --- значение целевой функции найденного решения алгоритмом оптимизации;

VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение ошибки по значениям целевой функции Ey.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.

Конкретную формулу, которые используются для нахождения для каждой тестовой функции, смотрите в функциях этих тестовых функций. Обратите внимание, что данная функция находит ошибку только для одного решения, тогда как по формулам нужно множество решений.

Все функции так высчитываются, чтобы алгоритм решал задачу поиска максимального значения целевой функции, поэтому тестовые функции на минимум умножаются на $-1$. Поэтому, фактически алгоритмы оптимизации находят максимум перевернутой функции. А значит, чтобы правильно посчитать ошибку по значениям целевой функции, нужно найденное решение умножить на $-1$.


\begin{lstlisting}[label=code_use_MHL_ErrorEyOfTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

int N=5;
double *x=new double[N];
MHL_RandomRealVector(x,-0.5,0.05,N);
double f=MHL_TestFunction_Real(x,N);

//Вызов функции
double Ey=MHL_ErrorEyOfTestFunction_Real(f,N);

//Использование результата
MHL_ShowVectorT(x,N,"Решение","x");
//Решение:
//x =
//-0.0963959	-0.183693	-0.0485428	-0.185757	0.0321075

MHL_ShowNumber(Ey,"Значение ошибки по значениям целевой функции","E<sub>y</sub>");
//Значение ошибки по значениям целевой функции:
//Ey=1.18549ы
\end{lstlisting}

\subsubsection{MHL\_ErrorROfTestFunction\_Binary}\label{MHL_ErrorROfTestFunction_Binary}

Функция определяет значение надежности найденного решения в задаче оптимизации для тестовой функции. Включает в себя все тестовые функции бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_ErrorROfTestFunction_Binary,caption=Синтаксис]
double MHL_ErrorROfTestFunction_Binary(int *x, int VMHL_N);
double MHL_ErrorROfTestFunction_Binary(int *x, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

x --- указатель на исходный массив (найденное решение алгоритмом);

VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение надежности R.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.

Конкретную формулу, которые используются для нахождения для каждой тестовой функции, смотрите в функциях этих тестовых функций. Обратите внимание, что данная функция находит ошибку только для одного решения, тогда как по формулам нужно множество решений.


\begin{lstlisting}[label=code_use_MHL_ErrorROfTestFunction_Binary,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

int N=5;
int *x=new int[N];
TMHL_RandomBinaryVector(x,N);

//Вызов функции
double R=MHL_ErrorROfTestFunction_Binary(x,N);

//Использование результата
MHL_ShowVectorT(x,N,"Решение","x");
//Решение:
//x =
//1	1	1	1	1

MHL_ShowNumber(R,"Значение надежности","R");
//Значение надежности:
//R=1
\end{lstlisting}

\subsubsection{MHL\_ErrorROfTestFunction\_Real}\label{MHL_ErrorROfTestFunction_Real}

Функция определяет значение надежности найденного решения в задаче оптимизации для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции  вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_ErrorROfTestFunction_Real,caption=Синтаксис]
double MHL_ErrorROfTestFunction_Real(double *x, int VMHL_N);
double MHL_ErrorROfTestFunction_Real(double *x, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

x --- указатель на исходный массив (найденное решение алгоритмом);

VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение надежности R.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.

Конкретную формулу, которые используются для нахождения для каждой тестовой функции, смотрите в функциях этих тестовых функций. Обратите внимание, что данная функция находит ошибку только для одного решения, тогда как по формулам нужно множество решений.


\begin{lstlisting}[label=code_use_MHL_ErrorROfTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

int N=5;
double *x=new double[N];
MHL_RandomRealVector(x,0.01,0.02,N);

//Вызов функции
double R=MHL_ErrorROfTestFunction_Real(x,N);

//Использование результата
MHL_ShowVectorT(x,N,"Решение","x");
//Решение:
//x =
//0.0118939	0.0177618	0.0115656	0.0181937	0.0124084

MHL_ShowNumber(R,"Значение надежности","R");
//Значение надежности:
//R=1
\end{lstlisting}

\subsubsection{MHL\_FitnessOfOptimumOfTestFunction\_Binary}\label{MHL_FitnessOfOptimumOfTestFunction_Binary}

Функция определяет значение целевой функции в оптимуме для тестовой функции бинарной оптимизации. Включает в себя все тестовые функции бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_FitnessOfOptimumOfTestFunction_Binary,caption=Синтаксис]
double MHL_FitnessOfOptimumOfTestFunction_Binary(int VMHL_N);
double MHL_FitnessOfOptimumOfTestFunction_Binary(int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение тестовой функции в оптимальной точке.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_FitnessOfOptimumOfTestFunction_Binary,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

int N=5;

//Вызов функции
double f=MHL_FitnessOfOptimumOfTestFunction_Binary(N);

//Использование результата
MHL_ShowNumber(f,"Значение целевой функции оптимального решения","f");
//Значение целевой функции оптимального решения:
//f=5
\end{lstlisting}

\subsubsection{MHL\_FitnessOfOptimumOfTestFunction\_Real}\label{MHL_FitnessOfOptimumOfTestFunction_Real}

Функция определяет значение целевой функции в оптимуме для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_FitnessOfOptimumOfTestFunction_Real,caption=Синтаксис]
double MHL_FitnessOfOptimumOfTestFunction_Real(double VMHL_N);
double MHL_FitnessOfOptimumOfTestFunction_Real(double VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение тестовой функции в оптимальной точке.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_FitnessOfOptimumOfTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

int N=5;

//Вызов функции
double f=MHL_FitnessOfOptimumOfTestFunction_Binary(N);

//Использование результата
MHL_ShowNumber(f,"Значение целевой функции оптимального решения функции TestFunction_Ackley","f");
//Значение целевой функции оптимального решения функции TestFunction_Ackley:
//f=0
\end{lstlisting}

\subsubsection{MHL\_GetCountOfFitness}\label{MHL_GetCountOfFitness}

Функция выдает количество вызовов целевой функции.


\begin{lstlisting}[label=code_syntax_MHL_GetCountOfFitness,caption=Синтаксис]
int MHL_GetCountOfFitness();
\end{lstlisting}

\textbf{Входные параметры:}

Отсутствуют.

\textbf{Возвращаемое значение:}
 
Количество вызовов целевой функции.

Данную функцию надо использовать в связке с функцией MHL\_GetCountOfFitness(). Для чего использовать эти функции? Дело в том, что для сравнения алгоритмов оптимизации очень критично оценивать вызов целевой функции. И часто многие программисты пишут или не очень акккуратно, или логика алгоритма такая, что заявленное число вычислений функций не совпадает с действительным. Поэтому в общие тестовые функции (например, MHL\_TestFunction\_Binary) вшит подсчет числа вызовов целевой функции.

MHL\_SetToZeroCountOfFitness --- эту функцию вызываем перед вызовом какого-то алгоритма оптимизации, а MHL\_GetCountOfFitness --- после его работы.


\begin{lstlisting}[label=code_use_MHL_GetCountOfFitness,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

MHL_SetToZeroCountOfFitness();

int N=5;
double f=0;
int *x=new int[N];

for (int i=0;i<10;i++)
{
    TMHL_RandomBinaryVector(x,N);
    f+=MHL_TestFunction_Binary(x,N);
}

f/=double(10.);

//Вызов функции
int M=MHL_GetCountOfFitness();

//Использование результата
MHL_ShowNumber(M,"Количество вызовов целевой функции","M");
//Количество вызовов целевой функции:
//M=10

MHL_ShowNumber(f,"Среднее значение целевой функции","f");
//Среднее значение целевой функции:
//f=2.6
\end{lstlisting}

\subsubsection{MHL\_GetCountOfSubProblems\_Binary}\label{MHL_GetCountOfSubProblems_Binary}

Функция определяет число подзадач (включая основную задачу) для тестовой функции бинарной оптимизации. Включает в себя все тестовые функции бинарной оптимизации.


\begin{lstlisting}[label=code_syntax_MHL_GetCountOfSubProblems_Binary,caption=Синтаксис]
int MHL_GetCountOfSubProblems_Binary();
int MHL_GetCountOfSubProblems_Binary(TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Отсутствуют.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.

Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Число подзадач (включая основную задачу) для тестовой функции.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_GetCountOfSubProblems_Binary,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

//Вызов функции
double N=MHL_GetCountOfSubProblems_Binary();

//Использование результата
MHL_ShowNumber(N,"Число подзадач (включая основную задачу) для TestFunction_SumVector","N");
//Число подзадач (включая основную задачу) для TestFunction_SumVector:
//N=10
\end{lstlisting}

\subsubsection{MHL\_GetCountOfSubProblems\_Real}\label{MHL_GetCountOfSubProblems_Real}

Функция определяет число подзадач (включая основную задачу) для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации.


\begin{lstlisting}[label=code_syntax_MHL_GetCountOfSubProblems_Real,caption=Синтаксис]
int MHL_GetCountOfSubProblems_Real();
int MHL_GetCountOfSubProblems_Real(TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Отсутствуют.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем. 

Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Число подзадач (включая основную задачу) для тестовой функции.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_GetCountOfSubProblems_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

//Вызов функции
double N=MHL_GetCountOfSubProblems_Real();

//Использование результата
MHL_ShowNumber(N,"Число подзадач (включая основную задачу) для TestFunction_Ackley","N");
//Число подзадач (включая основную задачу) для TestFunction_Ackley:
//N=7
\end{lstlisting}

\subsubsection{MHL\_LeftBorderOfTestFunction\_Real}\label{MHL_LeftBorderOfTestFunction_Real}

Функция определяет левые и правые границы допустимой области для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_LeftBorderOfTestFunction_Real,caption=Синтаксис]
void MHL_LeftAndRightBorderOfTestFunction_Real(double *Left, double *Right,int VMHL_N);
void MHL_LeftAndRightBorderOfTestFunction_Real(double *Left, double *Right, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Left --- указатель на массив, куда будет записываться результат левых границ допустимой области;

Right --- указатель на массив, куда будет записываться результат левых границ допустимой области;
	 
VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Отсутствует.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_LeftBorderOfTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

int N=5;
double *Left=new double[N];
double *Right=new double[N];

//Вызов функции
MHL_LeftAndRightBorderOfTestFunction_Real(Left,Right,N);

//Использование результата
MHL_ShowVectorT(Left,N,"Левые границы допустимой области функции TestFunction_Ackley","Left");
//Левые границы допустимой области функции TestFunction_Ackley:
//Left =	
//-5	-5	-5	-5	-5

MHL_ShowVectorT(Right,N,"Правые границы допустимой области функции TestFunction_Ackley","Right");
//Правые границы допустимой области функции TestFunction_Ackley:
//Right =	
//5	5	5	5	5
\end{lstlisting}

\subsubsection{MHL\_MaximumOrMinimumOfTestFunction\_Binary}\label{MHL_MaximumOrMinimumOfTestFunction_Binary}

	Функция сообщает - ищется максимум или минимум в задаче оптимизации для тестовой функции бинарной оптимизации.


\begin{lstlisting}[label=code_syntax_MHL_MaximumOrMinimumOfTestFunction_Binary,caption=Синтаксис]
double MHL_MaximumOrMinimumOfTestFunction_Binary();
double MHL_MaximumOrMinimumOfTestFunction_Binary(TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Отсутствуют.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
1 --- задача на нахождение максимума;

-1 --- задача на нахождение минимума.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_MaximumOrMinimumOfTestFunction_Binary,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

//Вызов функции
double MorM=MHL_MaximumOrMinimumOfTestFunction_Binary();

//Использование результата
MHL_ShowNumber(MorM,"Максимум или минимум функции находим у TestFunction_SumVector","MorM");
//Максимум или минимум функции находим у TestFunction_SumVector:
//MorM=1
\end{lstlisting}

\subsubsection{MHL\_MaximumOrMinimumOfTestFunction\_Real}\label{MHL_MaximumOrMinimumOfTestFunction_Real}

	Функция сообщает - ищется максимум или минимум в задаче оптимизации для тестовой функции вещественной оптимизации.


\begin{lstlisting}[label=code_syntax_MHL_MaximumOrMinimumOfTestFunction_Real,caption=Синтаксис]
double MHL_MaximumOrMinimumOfTestFunction_Real();
double MHL_MaximumOrMinimumOfTestFunction_Real(TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Отсутствуют.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
1 --- задача на нахождение максимума;

-1 --- задача на нахождение минимума.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_MaximumOrMinimumOfTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

//Вызов функции
double MorM=MHL_MaximumOrMinimumOfTestFunction_Real();

//Использование результата
MHL_ShowNumber(MorM,"Максимум или минимум функции находим у TestFunction_Ackley","MorM");
//Максимум или минимум функции находим у TestFunction_Ackley:
//MorM=-1
\end{lstlisting}

\subsubsection{MHL\_NumberOfPartsOfTestFunction\_Real}\label{MHL_NumberOfPartsOfTestFunction_Real}

Функция определяет на сколько частей нужно делить каждую координату в задаче оптимизации для тестовой функции вещественной оптимизации для алгоритма дискретной оптимизации и какая при этом требуется точность для подсчета надежности. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_NumberOfPartsOfTestFunction_Real,caption=Синтаксис]
double MHL_NumberOfPartsOfTestFunction_Real(int *NumberOfParts, int VMHL_N);
double MHL_NumberOfPartsOfTestFunction_Real(int *NumberOfParts, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

NumberOfParts --- указатель на массив, куда будет записываться результат;

VMHL\_N --- размер массива NumberOfParts.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Точность вычислений.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_NumberOfPartsOfTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

int N=5;
int *NumberOfParts=new int[N];

//Вызов функции
double e=MHL_NumberOfPartsOfTestFunction_Real(NumberOfParts,N);

//Использование результата
MHL_ShowVectorT(NumberOfParts,N,"На сколько частей нужно делить каждую координату функции TestFunction_Ackley","NumberOfParts");
//На сколько частей нужно делить каждую координату функции TestFunction_Ackley:
//NumberOfParts =	
//4095	4095	4095	4095	4095

MHL_ShowNumber(e,"Точность вычислений.","e");
//Точность вычислений.:
//e=0.025
\end{lstlisting}

\subsubsection{MHL\_OptimumOfTestFunction\_Binary}\label{MHL_OptimumOfTestFunction_Binary}

Функция определяет значение оптимума для тестовой функции. Включает в себя все тестовые функции бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_OptimumOfTestFunction_Binary,caption=Синтаксис]
double MHL_OptimumOfTestFunction_Binary(int *Optimum, int VMHL_N);
double MHL_OptimumOfTestFunction_Binary(int *Optimum, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Optimum --- указатель на исходный массив, куда будет записываться результат, то есть оптимум тестовой функции (максимум или минимум --- это зависит от типа тестовой функции, что расписывается в самих функциях тестовых функций);

     VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение тестовой функции в оптимальной точке.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_OptimumOfTestFunction_Binary,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

int N=5;
int *x=new int[N];

//Вызов функции
double f=MHL_OptimumOfTestFunction_Binary(x,N);

//Использование результата
MHL_ShowVectorT(x,N,"Оптимальное решение тестовой функции TestFunction_SumVector","x");
//Оптимальное решение тестовой функции TestFunction_SumVector:
//x =	
//1	1	1	1	1

MHL_ShowNumber(f,"Значение целевой функции оптимального решения","f");
//Значение целевой функции оптимального решения:
//f=5
\end{lstlisting}

\subsubsection{MHL\_OptimumOfTestFunction\_Real}\label{MHL_OptimumOfTestFunction_Real}

Функция определяет значение оптимума для тестовой функции вещественной оптимизации. Включает в себя все тестовые функции вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_OptimumOfTestFunction_Real,caption=Синтаксис]
double MHL_OptimumOfTestFunction_Real(double *Optimum, int VMHL_N);
double MHL_OptimumOfTestFunction_Real(double *Optimum, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Optimum --- указатель на исходный массив, куда будет записываться результат, то есть оптимум тестовой функции (максимум или минимум --- это зависит от типа тестовой функции, что расписывается в самих функциях тестовых функций);

     VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение тестовой функции в оптимальной точке.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_OptimumOfTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

int N=5;
double *x=new double[N];

//Вызов функции
double f=MHL_OptimumOfTestFunction_Real(x,N);

//Использование результата
MHL_ShowVectorT(x,N,"Оптимальное решение тестовой функции TestFunction_Ackley","x");
//Оптимальное решение тестовой функции TestFunction_Ackley:
//x =	
//0	0	0	0	0

MHL_ShowNumber(f,"Значение целевой функции оптимального решения","f");
//Значение целевой функции оптимального решения:
//f=0
\end{lstlisting}

\subsubsection{MHL\_PrecisionOfCalculationsOfTestFunction\_Real}\label{MHL_PrecisionOfCalculationsOfTestFunction_Real}

Функция определяет точность для подсчета надежности в задаче оптимизации для тестовой функции вещественной оптимизации для алгоритма дискретной оптимизации.


\begin{lstlisting}[label=code_syntax_MHL_PrecisionOfCalculationsOfTestFunction_Real,caption=Синтаксис]
double MHL_PrecisionOfCalculationsOfTestFunction_Real();
double MHL_PrecisionOfCalculationsOfTestFunction_Real(TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

Отсутствуют.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Точность вычислений.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.


\begin{lstlisting}[label=code_use_MHL_PrecisionOfCalculationsOfTestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

//Вызов функции
double e=MHL_PrecisionOfCalculationsOfTestFunction_Real();

//Использование результата
MHL_ShowNumber(e,"Точность вычислений","e");
//Точность вычислений:
//e=0.025
\end{lstlisting}

\subsubsection{MHL\_SetToZeroCountOfFitness}\label{MHL_SetToZeroCountOfFitness}

Функция обнуляет количество вызовов целевой функции. Обязательно вызвать один раз перед вызовом алгоритмов оптимизации при исследовании эффективности    алгоритмов оптимизации, где требуется контроль числа вызовов целевой функции.


\begin{lstlisting}[label=code_syntax_MHL_SetToZeroCountOfFitness,caption=Синтаксис]
void MHL_SetToZeroCountOfFitness();
\end{lstlisting}

\textbf{Входные параметры:}

Отсутствуют.

\textbf{Возвращаемое значение:}
 
Отсутствует.

Данную функцию надо использовать в связке с функцией MHL\_GetCountOfFitness(). Для чего использовать эти функции? Дело в том, что для сравнения алгоритмов оптимизации очень критично оценивать вызов целевой функции. И часто многие программисты пишут или не очень акккуратно, или логика алгоритма такая, что заявленное число вычислений функций не совпадает с действительным. Поэтому в общие тестовые функции (например, MHL\_TestFunction\_Binary) вшит подсчет числа вызовов целевой функции.

MHL\_SetToZeroCountOfFitness --- эту функцию вызываем перед вызовом какого-то алгоритма оптимизации, а MHL\_GetCountOfFitness --- после его работы.


\begin{lstlisting}[label=code_use_MHL_SetToZeroCountOfFitness,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

//Вызов функции
MHL_SetToZeroCountOfFitness();

//Использование результата
int N=5;
double f=0;
int *x=new int[N];

for (int i=0;i<10;i++)
{
    TMHL_RandomBinaryVector(x,N);
    f+=MHL_TestFunction_Binary(x,N);
}

f/=double(10.);

int M=MHL_GetCountOfFitness();
MHL_ShowNumber(M,"Количество вызовов целевой функции","M");
//Количество вызовов целевой функции:
//M=10

MHL_ShowNumber(f,"Среднее значение целевой функции","f");
//Среднее значение целевой функции:
//f=2.6
\end{lstlisting}

\subsubsection{MHL\_TestFunction\_Binary}\label{MHL_TestFunction_Binary}

Общая тестовая функция для задач бинарной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_TestFunction_Binary,caption=Синтаксис]
double MHL_TestFunction_Binary(int *x, int VMHL_N);
double MHL_TestFunction_Binary(int *x, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

x --- указатель на исходный массив;

VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение тестовой функции в точке x.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.

Все функции так высчитываются, чтобы алгоритм решал задачу поиска максимального значения целевой функции, поэтому тестовые функции на минимум умножаются на $-1$.


\begin{lstlisting}[label=code_use_MHL_TestFunction_Binary,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_SumVector);

int N=5;
int *x=new int[N];
TMHL_RandomBinaryVector(x,N);

//Вызов функции
double f=MHL_TestFunction_Binary(x,N);

//Использование результата
MHL_ShowVectorT(x,N,"Решение","x");
//Решение:
//x =
//1	1	1	1	0

MHL_ShowNumber(f,"Значение целевой функции","f");
//Значение целевой функции:
//f=4
\end{lstlisting}

\subsubsection{MHL\_TestFunction\_Real}\label{MHL_TestFunction_Real}

Общая тестовая функция для задач вещественной оптимизации. Есть функция-переопределение, где пользователь может сам указать тип тестовой функции.


\begin{lstlisting}[label=code_syntax_MHL_TestFunction_Real,caption=Синтаксис]
double MHL_TestFunction_Real(double *x, int VMHL_N);
double MHL_TestFunction_Real(double *x, int VMHL_N, TypeOfTestFunction Type);
\end{lstlisting}

\textbf{Входные параметры:}

x --- указатель на исходный массив;

VMHL\_N --- размер массива x.

В переопределяемой функции также есть параметр:
  
Type --- обозначение тестовой функции, которую вызываем.
Смотреть виды в переменных перечисляемого типа в начале HarrixMathLibrary.h файла: TestFunction\_Ackley, TestFunction\_ParaboloidOfRevolution, TestFunction\_Rastrigin и др. Они совпадают с названиями одноименных тестовых функций, но без приставки \textbf{MHL\_}.

\textbf{Возвращаемое значение:}
 
Значение тестовой функции в точке x.

Итак, для обычного использования (без параметра Type) нужно вызвать функцию MHL\_DefineTestFunction. Иначе использовать переопределенную функцию и самому указать тип тестовой функции.

Все функции так высчитываются, чтобы алгоритм решал задачу поиска максимального значения целевой функции, поэтому тестовые функции на минимум умножаются на $-1$.


\begin{lstlisting}[label=code_use_MHL_TestFunction_Real,caption=Пример использования]
MHL_DefineTestFunction(TestFunction_Ackley);

int N=5;
double *x=new double[N];
MHL_RandomRealVector(x,-1,1,N);

//Вызов функции
double f=MHL_TestFunction_Real(x,N);

//Использование результата
MHL_ShowVectorT(x,N,"Решение","x");
//Решение:
//x =
//-0.391724	0.347656	0.259155	-0.544617	0.116516

MHL_ShowNumber(f,"Значение целевой функции","f");
//Значение целевой функции:
//f=3.38932
\end{lstlisting}

\end{document}